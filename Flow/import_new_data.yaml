id: PSET_change_Log
namespace: company.team

tasks:
  - id: query_production_table
    type: io.kestra.plugin.jdbc.postgresql.Query
    url: jdbc:postgresql://postgresql_17:5432/portal
    username: postgres
    password: tKotT9xpeT
    sql: |
      SELECT DISTINCT ON (t."deviceId", t.pset_id)
        t.created_at,
        t."deviceId",
        CAST(ed.name AS text) AS device_name,
        t.pset_id,
        t.angle_min,
        t.angle_target,
        t.angle_max,
        t.torque_min,
        t.torque_target,
        t.torque_max,
        t.change_time
      FROM (
        SELECT
          "createdAt" AS created_at,
          "stringifiedDataJSON"->'payload'->>'parameterSetID'    AS pset_id,
          "stringifiedDataJSON"->'payload'->>'angleMin'          AS angle_min,
          "stringifiedDataJSON"->'payload'->>'finalAngleTarget'  AS angle_target,
          "stringifiedDataJSON"->'payload'->>'angleMax'          AS angle_max,
          "stringifiedDataJSON"->'payload'->>'torqueMinLimit'    AS torque_min,
          "stringifiedDataJSON"->'payload'->>'torqueFinalTarget' AS torque_target,
          "stringifiedDataJSON"->'payload'->>'torqueMaxLimit'    AS torque_max,
          "stringifiedDataJSON"->'payload'->>'timeLastChange'    AS change_time,
          "deviceId"
        FROM dbo."Order_EOR_test9"
        WHERE
          "createdAt" >= '2026-01-26'
          AND "createdAt" < '2026-01-27'
      ) t
      LEFT JOIN dbo."Equipment_Device" ed
        ON t."deviceId" = ed."id"
      ORDER BY
        t."deviceId",
        t.pset_id,
        t.created_at DESC;
    fetch: true
  
  - id: query_device_controller
    type: io.kestra.plugin.jdbc.postgresql.Query
    url: jdbc:postgresql://postgresql_17:5432/portal
    username: postgres
    password: tKotT9xpeT
    sql: |
      SELECT
        deviceid,
        devicename,
        toolserialnumber,
        controllerserialnumber
      FROM reporting.device_controller;
    fetch: true

  - id: query_baseline_table
    type: io.kestra.plugin.jdbc.postgresql.Query
    url: jdbc:postgresql://postgresql_17:5432/portal
    username: postgres
    password: tKotT9xpeT
    sql: |
      SELECT
        id,
        device,
        pset,
        time_last_change,
        created_at,
        update_at
      FROM reporting.device_pset_baseline;
    fetch: true
  
  - id: add_controller_field
    type: io.kestra.plugin.scripts.python.Script
    inputFiles:
      prod.json: "{{ outputs.query_production_table.rows | json }}"
      dc.json: "{{ outputs.query_device_controller.rows | json }}"
    outputFiles:
      - prod_plus_controller.json
    script: |
      import json

      def norm(v):
          if v is None:
              return None
          return str(v).strip()

      with open("prod.json") as f:
          prod = json.load(f)

      with open("dc.json") as f:
          dc = json.load(f)

      dc_map = {norm(d["devicename"]): d for d in dc if d.get("devicename")}
      
      enriched = []

      for p in prod:
          row = dict(p)
          devicename = norm(p.get("device_name"))
          
          match = dc_map.get(devicename)

          if match:
              row["controller_serial_number"] = match.get("controllerserialnumber")
          else:
            row["controller_serial_number"] = None

          enriched.append(row)
      with open("prod_plus_controller.json", "w") as f:
          json.dump(enriched, f)

  - id: compare_pset
    type: io.kestra.plugin.scripts.python.Script
    inputFiles:
      prod.json: "{{ json(read(outputs.add_controller_field.outputFiles['prod_plus_controller.json'])) }}"
      base.json: "{{ outputs.query_baseline_table.rows | json }}"
    outputFiles:
      - updates.json
      - new_record.json
    script: |
      from datetime import datetime, timezone
      import re
      import json

      TIME_FORMATS = [
        "%Y-%m-%d %H:%M:%S",
        "%Y-%m-%d:%H:%M:%S",
        "%Y-%m-%dT%H:%M:%S",
        "%Y-%m-%dT%H:%M:%SZ",
      ]

      def parse_time(v):
        if v is None:
            return None

        if isinstance(v, datetime):
            return v.astimezone(timezone.utc) if v.tzinfo else v.replace(tzinfo=timezone.utc)

        if isinstance(v, str):
            v = v.strip()
            for fmt in TIME_FORMATS:
                try:
                    dt = datetime.strptime(v, fmt)
                    return dt.replace(tzinfo=timezone.utc)
                except ValueError:
                    pass
            raise ValueError(f"Unsupported datetime format: {v}")

        return None

      def norm_key(v):
        if v is None:
            return None
        if isinstance(v, str):
            return " ".join(v.strip().split())
        return v

      with open("prod.json") as f:
        prod = json.load(f)

      with open("base.json") as f:
        base = json.load(f)
      
      base_map = {
          (norm_key(b.get("device")), norm_key(b.get("pset"))): b
          for b in base
      }

      new_record = []
      updates = []
      
      for p in prod:
        Device_name = norm_key(p.get("device_name"))
        pset = norm_key(p.get("pset_id"))
        
        b = base_map.get((Device_name, pset))
        
        if not b: #find new record 
          new_record.append({
              "device": p.get("device_name"),
              "pset": pset,
              "time_last_change": p.get("change_time"),
          })
          continue

        if parse_time(p.get("change_time")) != parse_time(b.get("time_last_change")):
          updates.append({
            "controller_id": (
                p.get("controller_serial_number")
                if p.get("controller_serial_number") is not None
                else "__NULL__"
            ),
            "device": p.get("device_name"),
            "pset": pset,
            "time_last_change": p.get("change_time"),
            "torque_min": p.get("torque_min"),
            "torque_target": p.get("torque_target"),
            "torque_max": p.get("torque_max"),
            "angle_min": p.get("angle_min"),
            "angle_target": p.get("angle_target"),
            "angle_max": p.get("angle_max"),
            })

      with open("updates.json", "w") as f:
          json.dump(updates, f)
      with open("new_record.json", "w") as f:
          json.dump(new_record, f)


  - id: apply_pset_insert_new_record
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ json(read(outputs.compare_pset.outputFiles['new_record.json'])) }}"
    tasks:
      - id: insert_pset
        type: io.kestra.plugin.jdbc.postgresql.Query
        url: jdbc:postgresql://postgresql_17:5432/portal
        username: postgres
        password: tKotT9xpeT
        sql: |
          INSERT INTO reporting.device_pset_baseline (
              device,
              pset,
              time_last_change,
              created_at,
              update_at
          )
          VALUES (
              '{{ json(taskrun.value).device }}',
              '{{ json(taskrun.value).pset }}',
              '{{ json(taskrun.value).time_last_change }}',
              CURRENT_TIMESTAMP,
              CURRENT_TIMESTAMP
          );

  - id: apply_pset_update
    type: io.kestra.plugin.core.flow.ForEach
    values: "{{ json(read(outputs.compare_pset.outputFiles['updates.json'])) }}"
    tasks:
      - id: update_base_line_and_insert_change_log
        type: io.kestra.plugin.jdbc.postgresql.Query
        url: jdbc:postgresql://postgresql_17:5432/portal
        username: postgres
        password: tKotT9xpeT
        sql: |
          BEGIN;

          UPDATE reporting.device_pset_baseline
          SET
            time_last_change = '{{ json(taskrun.value).time_last_change }}',
            update_at = CURRENT_TIMESTAMP
          WHERE device = '{{ json(taskrun.value).device }}'
            AND pset = '{{ json(taskrun.value).pset }}';

          INSERT INTO reporting.pset_change_log (
            controller_id,
            device,
            pset,
            time_last_change,
            rev,
            createdat,
            torque_min,
            torque_target,
            torque_max,
            angle_min,
            angle_target,
            angle_max
          )
          VALUES (
            NULLIF('{{ json(taskrun.value).controller_id }}', '__NULL__'),
            '{{ json(taskrun.value).device }}',
            '{{ json(taskrun.value).pset }}',
            '{{ json(taskrun.value).time_last_change }}',
            '0',
            CURRENT_TIMESTAMP,
            {{ json(taskrun.value).torque_min }},
            {{ json(taskrun.value).torque_target }},
            {{ json(taskrun.value).torque_max }},
            {{ json(taskrun.value).angle_min }},
            {{ json(taskrun.value).angle_target }},
            {{ json(taskrun.value).angle_max }}
          );

          COMMIT;

  - id: cleanup
    type: io.kestra.plugin.core.execution.PurgeExecutions
    namespace: "{{ flow.namespace }}"
    flowId: "{{ flow.id }}"
    endDate: "{{ now() }}"
    states:
      - SUCCESS


# triggers:
#   - id: schedule
#     type: io.kestra.plugin.core.trigger.Schedule
#     cron: "*/10 * * * *"
